[
    {
        "category": "测试基础",
        "subcategory": "软件生命周期",
        "question": "软件生命周期的定义是什么?",
        "answer": "一个计算机软件从功能确定、设计、开发、测试到投入使用, 并在使用中不断完善的全过程。"
    },
    {
        "category": "测试基础",
        "subcategory": "软件生命周期",
        "question": "软件生命周期的阶段有哪些?",
        "answer": "可行性分析-需求分析-总体设计-概要设计-详细设计-编码-测试-维护"
    },
    {
        "category": "测试基础",
        "subcategory": "软件生命周期",
        "question": "软件生命周期有哪些常见的模型?",
        "answer": "瀑布模型(软件生命周期各项活动按固定顺序连接); 敏捷开发(通过短周期迭代, 不断交付新的软件版本, 逐步满足客户需求; 比较强调团队协作客户参与和对变化的快速响应); 另外还有螺旋模型、增量模型等等。"
    },
    {
        "category": "测试基础",
        "subcategory": "软件生命周期",
        "question": "V模型是什么?",
        "answer": "V模型是一种开发阶段从左到右依次进行的软件开发模型。流程由需求分析到概要设计到详细设计到编码, 再到单元测试、集成测试、系统测试最后验收测试, 测试开发阶段一一对应呈V字形"
    },
    {
        "category": "测试基础",
        "subcategory": "软件生命周期",
        "question": "W模型是什么?",
        "answer": "W模型又叫双V模型是一种每个开发阶段对应特定测试阶段的一种软件开发模型, 用户需求对应验收测试设计、需求分析对应系统测试设计、概要设计对应集成测试设计、详细设计对应单元测试设计, 编码对应单元测试、集成对应集成测试、实施对应系统测试、交付对应验收测试。更早进行测试能更早发现问题"
    },
    {
        "category": "测试基础",
        "subcategory": "软件生命周期",
        "question": "质量模型是什么?",
        "answer": "质量模型用来描述和评估软件质量, 一般从功能、性能、兼容、易用、安全、可靠、可维护和可移植性这几个方面考虑。"
    },
    {
        "category": "测试基础",
        "subcategory": "软件生命周期",
        "question": "什么是软件测试？​",
        "answer": "软件测试是通过手动或自动方式验证软件是否满足需求，并发现缺陷的过程。目的是确保软件质量，降低风险。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试分类",
        "question": "测试的分类有哪些?(按测试阶段划分)",
        "answer": "按照测试阶段来划分的话, 大概可以分为单元测试, 就是对软件的最小可测单元进行验证。然后是集成测试, 是对各个单元组成的模块之间的接口和集成的功能进行测试。然后是系统测试, 就是在模拟的真实运行环境下对软件的功能、性能等各方面进行全面测试。然后是验收测试, 一般是由相关用户或者独立测试人员验证系统是否满足业务需求和客户要求。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试分类",
        "question": "测试的分类有哪些?(按代码可见度划分)",
        "answer": "按照代码可见度划分, 一般可以分为白盒测试、黑盒测试和灰盒测试。白盒测试是基于程序内部逻辑结构进行测试​​，比如单元测试; 黑盒测试不考虑软件内部结构, 从用户需求出发, 关注软件功能是否正确实现，比如功能测试。灰盒测试在两者之间, 指在知道部分软件内部结构的情况下关注于功能实现, 比如接口测试。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试分类",
        "question": "冒烟测试是什么?",
        "answer": "冒烟测试是指在大规模执行测试前对程序主要功能/模块进行验证, 保证程序具有可测性。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试分类",
        "question": "回归测试是什么?",
        "answer": "回归测试是指在软件发生代码修改(功能新增、系统重构)之后, 重新执行全部或者部分以前的测试用例, 验证程序软件原有功能是否正常、新变更是否引入新错误。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试流程",
        "question": "你了解测试流程吗?",
        "answer": "测试流程一般有需求分析、测试计划编写、测试用例设计、测试用例执行、缺陷跟踪管理到测试报告生成。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试流程",
        "question": "在需求分析阶段测试人员为什么要参与?",
        "answer": "确保各部门之间需求理解一致, 可以查漏补缺。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试流程",
        "question": "测试计划要有哪些内容?",
        "answer": "测什么?谁来测?怎么测?测什么就是确定测试目标和范围; 谁来测是来确定人员进度安排; 怎么测是确定测试策略、测试工具、测试环境等。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试流程",
        "question": "缺陷的定义是什么?",
        "answer": "软件使用过程中存在的任何问题。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试流程",
        "question": "缺陷的判断标准是什么?",
        "answer": "看用户需求规格说明书, 一般有少功能、多功能、功能错误、隐性的功能错误、不易使用这些方面。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试流程",
        "question": "软件缺陷的类型有哪些?",
        "answer": "软件缺陷类型有功能缺陷、界面缺陷、兼容性、易用性等。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试流程",
        "question": "软件缺陷的提交要素有哪些?",
        "answer": "一般有缺陷ID、缺陷标题、所属模块、状态、优先级、缺陷描述(包括前置条件、复现步骤、期望结果和实际结果), 最后附上附件作证明。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试流程",
        "question": "软件缺陷的跟踪流程是什么?",
        "answer": "一般由测试人员提交缺陷、分派缺陷, 再由开发人员进行确定（看bug是否重复提交、是否确定是bug、是否推迟处理）, 然后进行修复, 测试人员进行验证, 通过后关闭, 未通过重新打开。"
    },
    {
        "category": "测试基础",
        "subcategory": "测试流程",
        "question": "测试报告要有哪些内容?",
        "answer": "测试报告一般要有测试目标、测试过程、测试范围、测试结果(包括缺陷统计和分析)、测试结论。"
    },
    {
        "category": "测试基础",
        "subcategory": "功能测试",
        "question": "测试用例的要素有哪些?",
        "answer": "一般由用例ID、用例标题、所属模块、优先级、前置条件、测试数据、测试步骤、预期结果组成。"
    },
    {
        "category": "测试基础",
        "subcategory": "功能测试",
        "question": "你知道哪些测试用例的设计方法?",
        "answer": "一般有等价类划分法将输入数据分类（如有效/无效输入）每类选代表测试、边界值分析法测试输入范围的边界、判定表法、因果图法、错误推断法基于经验测易错点、场景法模拟用户操作流程。"
    },
    {
        "category": "测试基础",
        "subcategory": "功能测试",
        "question": "介绍一下等价类划分法?",
        "answer": "等价类划分法主要是针对有大量数据输入但无法穷举的场景, 将程序的输入划分为若干个等价类, 等价类是输入中具有某种共同特征的数据子集, 然后从每个等价类中选取代表性的数据来测试, 这样能提升测试效率并保证测试的完整性。"
    },
    {
        "category": "测试基础",
        "subcategory": "功能测试",
        "question": "介绍一下边界值分析法?",
        "answer": "边界值分析法一般和等价类划分法结合使用, 因为很多软件缺陷出现在输入边界上而非内部, 所以边界值分析法重点关注边界值情况, 在划分的等价类的边界(比如上点离点)进行测试。"
    },
    {
        "category": "测试基础",
        "subcategory": "功能测试",
        "question": "介绍一下判定表法?",
        "answer": "判定表法用于分析多条件逻辑判断, 将复杂的条件组合和对应的动作以表格形式呈现。"
    },
    {
        "category": "测试基础",
        "subcategory": "功能测试",
        "question": "介绍一下因果图法?",
        "answer": "因果图法通过图形符号表示输入条件和输出结果之间关系, 适用于描述多种条件的组合, 并产生多个不同结果的情况, 核心在于考虑输入条件之间的相互制约及组合关系, 以及输出结果对输入条件的依赖关系。"
    },
    {
        "category": "测试基础",
        "subcategory": "功能测试",
        "question": "判定表法和因果图法有什么异同?",
        "answer": "判定表法和因果图法的相同点在于都是为了更全面有效地找出系统在不同输入条件组合下的输出情况。不同点在于判定表法侧重于对输入条件组合的穷举分析, 不强调条件之间的逻辑关系, 适用于输入条件较少、相互关系相对简单的情况, 比如简单的登录功能; 而因果图法则更注重分析输入条件之间的因果关系, 以及输入和输出之间的约束关系, 适用于输入条件较多、相互关系复杂的情况, 比如电商的促销活动。"
    },
    {
        "category": "测试基础",
        "subcategory": "功能测试",
        "question": "介绍一下错误推断法?",
        "answer": "错误推断法基于测试人员的经验来推测系统可能出现错误的地方, 并针对性地设计测试用例。"
    },
    {
        "category": "测试基础",
        "subcategory": "功能测试",
        "question": "介绍一下场景法?",
        "answer": "场景法针对业务场景, 通过模拟用户在实际使用软件过程中的各种场景来进行测试。可以在编写时弄清业务的流程图, 了解业务的成功条件和失败条件, 以此来编写正向的、反向的用例。"
    },
    {
        "category": "测试基础",
        "subcategory": "接口测试",
        "question": "什么是接口?",
        "answer": "接口是系统与系统之间/组件与组件之间数据传递交互的通道。"
    },
    {
        "category": "测试基础",
        "subcategory": "接口测试",
        "question": "接口测试的目的是什么?为什么要做接口测试？​",
        "answer": "接口测试的目的是验证系统各个组件之间的接口是否正常, 并确保数据的正确传递。不用等前端开发完就能测逻辑, 可以提前发现问题。一个接口bug可能影响多个功能, 可以高效覆盖​​。"
    },
    {
        "category": "测试基础",
        "subcategory": "接口测试",
        "question": "你知道接口文档的结构吗?",
        "answer": "一般有接口名称、接口地址、请求方式、接口描述、请求参数、响应参数等。"
    },
    {
        "category": "测试基础",
        "subcategory": "接口测试",
        "question": "接口测试的测试用例要有哪些?",
        "answer": "一般有用例子ID、用例名、模块、优先级、前置条件、URL、请求方法、请求头、请求体、预期结果、实际结果。"
    },
    {
        "category": "测试基础",
        "subcategory": "接口测试",
        "question": "接口测试的测试点有哪些?",
        "answer": "从功能方面一般有单接口测试, 主要是从参数和数值方面考虑, 参数就是多参、少参、无参和错参, 数值上类似功能测试使用等价类划分的方法; 还可以多接口测试, 一个用例覆盖多个接口。另外就是从性能上比如响应时间或者从安全上比如SQL注入等方面考虑。"
    },
    {
        "category": "测试基础",
        "subcategory": "接口测试",
        "question": "接口测试如果响应时间长怎么办?",
        "answer": "可以考虑使用异步接口, 比如消息队列, 可以把耗时的操作放到消息队列中, 然后接口直接返回成功, 异步处理。"
    },
    {
        "category": "测试基础",
        "subcategory": "接口测试",
        "question": "接口测试没有接口文档的情况下怎么办?",
        "answer": "通过抓包工具（如Charles/Fiddler）或浏览器开发者工具捕获前端操作触发的HTTP请求，记录URL、方法、请求头、参数及响应结构/在测试过程中逐步整理接口信息；还可以使用各个工具的脚本录制功能,可以录制操作自动捕获接口请求并生成可复用的测试脚本。"
    },
    {
        "category": "测试基础",
        "subcategory": "自动化测试",
        "question": "说说自动化测试技术的应用场景/测试人员哪些工作环节适合用到自动化技术?",
        "answer": "1. 回归测试（高频执行相同用例）；2. 冒烟测试（持续集成自动触发）3. 监控报警（生产环境巡检）"
    },
    {
        "category": "测试基础",
        "subcategory": "自动化测试",
        "question": "自动化测试覆盖率是什么？​",
        "answer": "自动化测试覆盖率是指使用自动化测试执行的用例数与手工执行的用例数量的比率。（测试覆盖率是衡量测试用例覆盖整个应用程序代码的百分比，帮助识别测试中的差距）"
    },
    {
        "category": "测试基础",
        "subcategory": "自动化测试",
        "question": "什么是UI自动化测试？哪些场景适合做UI自动化？",
        "answer": "UI自动化测试就是用工具（如Selenium）模拟用户操作界面，自动执行测试用例。比较适合核心高频操作的场景，还有大量数据反复测试同一流程，不适合频繁变动的页面。"
    },
    {
        "category": "测试基础",
        "subcategory": "自动化测试",
        "question": "​UI自动化脚本跑得时快时慢，怎么优化？​",
        "answer": ""
    },
    {
        "category": "测试基础",
        "subcategory": "自动化测试",
        "question": "如何设计 Page Object Model(POM)？​有什么好处？",
        "answer": "PO模式就是把每个页面看为一个对象, 页面元素定位作为属性。页面元素操作作为方法。测试用例执行调用页面对象, 实现了业务逻辑和元素定位的分离。代码复用（多个测试脚本共用同一页面的操作）、可读性强、易维护（页面元素变了只需改一个类文件）"
    },
    {
        "category": "测试基础",
        "subcategory": "自动化测试",
        "question": "PO模式中BasePage的作用？​",
        "answer": "BasePage是所有页面的父类, 主要是封装了一些通用方法, 比如元素定位、元素操作等。"
    },
    {
        "category": "测试基础",
        "subcategory": "自动化测试",
        "question": "什么是数据驱动？？什么是关键字驱动？",
        "answer": "数据驱动是指测试用例的数据来自外部数据源, 而不是硬编码在测试脚本中。关键字驱动是指测试用例的执行逻辑由关键字组成, 而不是直接执行操作。[<a href='https://www.cnblogs.com/juno3550/p/14431902.html'>关键字驱动+数据驱动项目示例</a>]"
    },
    {
        "category": "测试基础",
        "subcategory": "自动化测试",
        "question": "自动化测试中因为网络抖动导致的测试失败怎么办？（如何实现自动化测试失败重试）",
        "answer": "可以使用 pytest 的 pytest-rerunfailures 插件。然后通过命令行或者装饰器设置reruns。或者使用retrying 库的retry作为装饰器。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "性能测试的目的是什么?",
        "answer": "性能测试的目的主要是为了评估当前系统能力; 寻找性能瓶颈, 优化性能; 评估是否满足未来的需要。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "性能测试和功能测试有什么不同?",
        "answer": "功能测试验证​​系统能否正常工作；性能测试验证​​系统能否高效稳定工作​​。性能测试关注重点在于时间和资源方面的非功能性需求。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "性能测试的策略有哪些?",
        "answer": "常见的有基准测试、负载测试、稳定性测试、压力测试、并发测试。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "请介绍一下基准测试",
        "answer": "基准测试通过基准测试环境下的测试, 可以知晓系统基础性能表现, 为后续性能优化提供原始参照数据。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "请介绍一下压力测试",
        "answer": "压力测试在高负载的情况下, 看看系统峰值时的容错能力、可恢复能力。。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "请介绍一下稳定性测试",
        "answer": "稳定性测试是正常负载下长时间的稳定运行测试。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "请介绍一下并发测试",
        "answer": "并发测试是在同一时间发送多个请求, 主要是检查系统有没有并发问题。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "请介绍一下负载测试",
        "answer": "负载测试逐步增加系统负载, 寻找满足性能指标情况下的最大负载量"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "性能测试的指标有哪些?",
        "answer": "常见的有响应时间、并发数、资源利用率、吞吐量、点击率、错误率。响应时间是指客户端从发送请求到接收到响应的总时间。并发数是指同一时刻向服务器发送请求的用户数。资源利用率就是系统各种资源比如CPU、内存的使用情况。吞吐量是指系统单位时间内处理的客户端请求数。点击率是指一个页面之内所有元素的请求总数量。错误率是指系统在负载情况下业务失败的概率。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "吞吐量的单位是什么?",
        "answer": "存储量的单位有 TPS 和 QPS, TPS 是服务器每秒处理的事务请求数量, QPS 是服务器每秒处理的查询请求数量, 一个事务可能会对应一个或多个查询。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "性能测试的流程是什么?",
        "answer": "性能测试流程有性能需求分析、性能测试计划设、性能测试用例设计、性能测试执行和调优、测试报告生成。"
    },
    {
        "category": "测试基础",
        "subcategory": "性能测试",
        "question": "性能测试的测试用例要素有哪些?",
        "answer": "性能测试的测试用例要素有用例ID、用例标题、用例描述、前置条件、测试步骤、预期结果和实际结果, 实际结果包含系统事务性能指标、应用服务器和数据库服务器的资源利用率。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python的数据类型你都有哪些了解?",
        "answer": "有数字类型, 如整型浮点型; 有序列类型, 如字符串、列表、元组; 有集合类型; 映射类型(字典);布尔类型。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python的可变类型和不可变类型有哪些?",
        "answer": "可变类型有列表、字典、集合; 不可变类型有字符串、元组、数字。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python ​​列表和元组的区别?",
        "answer": "列表是可变的, 元组是不可变的。列表用方括号表示, 元组用圆括号表示。列表可以进行增删改查, 元组不能进行修改。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python的字典是什么?如何合并字典？",
        "answer": "字典是一种键值对的数据结构, 由键和值组成, 键必须是不可变类型, 值可以是任意类型。合并字典可以使用 update() 方法（dict2.update(dict1)）,或者字典推导式, 或者解包操作符**。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python的集合是什么?",
        "answer": "集合是一种无序且不重复的元素集合, 可以进行交集、并集、差集等操作。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python的字符串是什么?",
        "answer": "字符串是由字符组成的不可变序列, 可以进行切片、拼接、查找等操作。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python如何实现列表去重？",
        "answer": "可以使用 set 集合去重。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python迭代器了解吗?",
        "answer": "迭代器会按需生成数据, 只有在用 next() 函数或者通过循环去访问的时候才会生成相应元素, 可以节省内存。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python生成器了解吗?",
        "answer": "生成器一种特殊的迭代器, 有yield关键字, 执行到它会暂停并返回值, 再次调用会从暂停处继续。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python闭包了解吗?闭包的意义和使用场景?",
        "answer": "当一个函数嵌套在另一个函数内部, 并且内部函数引用了外部函数的变量时, 就形成了闭包。即使外部函数已经执行完毕, 闭包仍然可以访问外部函数的变量。所以可以将一些数据封装在闭包内部, 外部无法直接访问, 只能通过闭包提供的方法来操作。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python装饰器了解吗?",
        "answer": "装饰器给原函数套了一个壳, 在原函数执行前后增加额外操作,可以在不更改原函数的情况下增加功能。​比如解决接口的未鉴权问题（普通用户直接访问/admin/delete接口能删数据）。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python中如何实现多进程?多线程?协程?",
        "answer": "可以使用 multiprocessing 模块来实现多进程。可以使用 threading 模块来实现多线程。可以使用 asyncio 模块来实现协程。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "如何用 Python 模拟高并发请求？​",
        "answer": "可以使用 threading+requests/ asyncio+aiohttp 来模拟高并发请求。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "解释 Python里 *args 和 **kwargs 的作用？​",
        "answer": "*args 用于接收任意数量的位置参数, 以元组形式存储。**kwargs 用于接收任意数量的关键字参数, 以字典形式存储。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python 用 with 语句处理文件操作的优点是什么？​",
        "answer": "with 语句会自动关闭文件, 避免资源泄漏, 还能自动处理异常。"
    },
    {
        "category": "编程基础",
        "subcategory": "Python",
        "question": "Python 如何读取 Excel 测试数据？​",
        "answer": "可以使用 openpyxl 库(workbook、sheet)来读取 Excel 测试数据。"
    },
    {
        "category": "编程基础",
        "subcategory": "JavaScript",
        "question": "var、let、const的区别是什么？如何选择？",
        "answer": "var存在变量提升和函数作用域，let和const有块级作用域；let用于可变变量，const用于不可变变量（对象/数组内部可修改），优先使用const，其次let，避免使用var。"
    },
    {
        "category": "编程基础",
        "subcategory": "JavaScript",
        "question": "如何判断一个变量的类型？（typeof vs instanceof）",
        "answer": "typeof用于基本类型（除null外）和函数，返回字符串；instanceof用于检测对象是否为某构造函数的实例，不适用于基本类型。"
    },
    {
        "category": "编程基础",
        "subcategory": "JavaScript",
        "question": "箭头函数和普通函数的区别是什么？",
        "answer": "箭头函数无自己的this、arguments、super和new.target，不能作为构造函数，没有prototype属性，适合回调和简短函数。"
    },
    {
        "category": "编程基础",
        "subcategory": "JavaScript",
        "question": "解释this的指向规则。",
        "answer": "this指向调用者：普通函数中指向全局对象（非严格模式）或undefined（严格模式），对象方法中指向对象，构造函数中指向实例，call/apply/bind可显式指定。"
    },
    {
        "category": "编程基础",
        "subcategory": "JavaScript",
        "question": "Promise、async/await和回调函数的区别？",
        "answer": "回调函数是将一个函数作为参数传递给另一个函数，当该函数执行完成后，会调用这个作为参数的函数，需手动处理嵌套（太多则回调地狱）和错误；Promise是用于处理异步操作的对象，解决回调地狱，通过then/catch链式调用；async/await是Promise语法糖，使异步代码像同步。"
    },
    {
        "category": "编程基础",
        "subcategory": "JavaScript",
        "question": "如何用JS实现一个简单的DOM操作（如点击按钮触发事件）？",
        "answer": "document.getElementById('btn').addEventListener('click', () => { console.log('Button clicked'); });"
    },
    {
        "category": "编程基础",
        "subcategory": "JavaScript",
        "question": "如何通过JS获取页面元素的属性值？",
        "answer": "const value = document.querySelector('input').value;"
    },
    {
        "category": "编程基础",
        "subcategory": "JavaScript",
        "question": "AJAX、XHR、jQuery、fetch、axios、Promise、async/await 都是什么？",
        "answer": "​​AJAX​​ 是一种技术方案（异步更新网页内容）, 最初通过 ​​XHR​​（底层 API）实现, 后演进为基于 ​​Promise​​ 的 ​​Fetch​​（原生）和功能更强的 ​​axios​​（第三方库）, ​​Promise​​ 是异步编程的基础机制, 表示异步最终操作完成/失败及其结果值; ​​async/await​​ 是基于 Promise 的语法糖, async 用于申明一个函数是异步的, 而 await 用于等待一个异步方法执行完成"
    },
    {
        "category": "编程基础",
        "subcategory": "前端",
        "question": "如何用 CSS 实现一个元素的垂直居中？",
        "answer": "Flex 布局（父容器 `display: flex; align-items: center;`）或绝对定位 + `transform: translateY(-50%)`。  "
    },
    {
        "category": "编程基础",
        "subcategory": "前端",
        "question": "Flex 布局和 Grid 布局的区别？实际项目中如何选择？",
        "answer": "Flex 适合一维布局（行或列）, Grid 适合二维布局（复杂网格）；在测试中需关注不同浏览器的兼容性（如 IE 对 Grid 支持较差）。"
    },
    {
        "category": "编程基础",
        "subcategory": "前端",
        "question": "什么是 CSS 盒模型？​",
        "answer": "在 CSS（层叠样式表）中, 将网页中的每个元素都看作是一个矩形的盒子, 这个盒子由内容区域（content）、内边距（padding）、边框（border）和外边距（margin）组成。"
    },
    {
        "category": "编程基础",
        "subcategory": "前端",
        "question": "Vue是什么？有什么优点？​",
        "answer": "Vue 是一种渐进式 JavaScript 框架, 用于构建用户界面。Vue 的优点包括轻量、灵活、响应式、组件化等。"
    },
    {
        "category": "编程基础",
        "subcategory": "前端",
        "question": "Vue的生命周期（钩子）有哪些？​",
        "answer": "Vue 的生命周期包括创建前/后、挂载前/后、更新前/后、销毁前/后。"
    },
    {
        "category": "编程基础",
        "subcategory": "前端",
        "question": "Vuex是什么？状态是什么？如何在组件间共享状态？​",
        "answer": "Vuex 是 Vue 官方提供的状态管理库, 用于集中管理 Vue 应用的状态。状态是应用程序中存储的数据, 可以是全局状态、组件状态等。可以通过 Vuex 的 store 来管理状态, 然后通过组件的 computed 属性或方法来读取或修改状态。"
    },
    {
        "category": "编程基础",
        "subcategory": "前端",
        "question": "Vue（响应式原理）双向绑定是什么？怎么实现？​",
        "answer": "当数据发生变化时，视图会自动更新；反之，当视图发生变化时，数据也会同步更新。通过 Object.defineProperty () 方法对数据对象的属性进行劫持，当数据变化时，通知订阅者（即视图相关的更新函数）更新视图；同时，视图上的事件（如输入框输入事件）触发时，会更新对应的数据。"
    },
    {
        "category": "编程基础",
        "subcategory": "前端",
        "question": "Vue 组件的 Props 和 Events?​",
        "answer": "Props 是组件的属性，用于父组件向子组件传递数据；Events 是组件的事件，子组件通过触发事件来向父组件传递信息或通知父组件执行某些操作。"
    },
    {
        "category": "编程基础",
        "subcategory": "前端",
        "question": "v-if 和 v-show 的区别？性能影响如何？​",
        "answer": "v-if 是条件渲染, 当条件为 false 时, 元素不会渲染; v-show 是通过 CSS 的 display 属性来控制元素的显示/隐藏。v-if 有更高的切换开销, 因为它会销毁和重建元素; v-show 有更高的初始渲染开销, 因为它会始终渲染元素, 只是通过 CSS 控制显示/隐藏。"
    },
    {
        "category": "编程基础",
        "subcategory": "Java",
        "question": "Java中final关键字的作用？​",
        "answer": "修饰变量​​：变量值不可变。​​修饰方法​​：方法不可被子类重写。​​修饰类​​：类不可被继承。"
    },
    {
        "category": "编程基础",
        "subcategory": "Java",
        "question": "Java中接口和抽象类的区别？​",
        "answer": "接口是一种约定, 定义了一组方法, 但没有具体实现; 抽象类是一种模板, 包含抽象方法和具体方法, 不能被实例化，只能被继承，子类必须实现抽象方法。不同之处比如接口不能有成员变量（除了静态常量），而抽象类可以有普通成员变量；一个类只能继承一个抽象类，但能实现多个接口等。"
    },
    {
        "category": "编程基础",
        "subcategory": "Java",
        "question": "Java中多态是什么？实现方式？​",
        "answer": "多态是指同一个类型的对象在不同的场景下表现出不同的行为。实现方式包括方法重载（同一个类中，允许存在多个同名方法，但这些方法的参数列表（参数个数、类型或顺序）不同）和方法重写（子类中定义了与父类中方法签名（方法名、参数列表、返回类型）完全相同的方法。当子类对象调用该方法时，实际执行的是子类重写后的方法。）。"
    },
    {
        "category": "编程基础",
        "subcategory": "Java",
        "question": "Java中异常处理机制是什么？​",
        "answer": "Java 中的异常处理机制包括 try-catch-finally 块, 用于捕获和处理异常。"
    },
    {
        "category": "编程基础",
        "subcategory": "Java",
        "question": "Java中集合框架有哪些？​",
        "answer": "Java 中的集合框架包括 List、Set、Map 等接口和它们的实现类。"
    },
    {
        "category": "编程基础",
        "subcategory": "Java",
        "question": "Java中反射（Reflection）是什么​？​",
        "answer": "反射是一种机制, 允许程序在运行时动态地获取类的信息, 并调用类的方法、访问类的属性等。"
    },
    {
        "category": "编程基础",
        "subcategory": "Java",
        "question": "Java中注解（Annotation）是什么​？​",
        "answer": "注解是一种元数据, 用于为程序元素（类、方法、字段等）添加额外的信息。注解可以用于编译时检查、运行时处理、生成文档等。"
    },
    {
        "category": "编程基础",
        "subcategory": "安卓",
        "question": "Android 四大组件了解吗？​",
        "answer": "四大组件分别是 Activity活动、Service服务(后台长时间运行)、BroadcastReceiver(接收系统或应用发出的广播消息)、ContentProvider(不同的应用之间共享数据)。"
    },
    {
        "category": "编程基础",
        "subcategory": "安卓",
        "question": "解释Intent的作用和使用场景。​",
        "answer": "Intent是一种用于组件之间通信的机制, 可以启动其他组件、传递数据、启动服务等。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Fiddler",
        "question": "Fiddler的工作原理是什么?",
        "answer": "Fiddler是一个HTTP代理服务器, 本地应用与服务器之间所有的请求和响应都由其进行中转, 因此Fiddler能够截取数据信息, 显示网络数据的抓包内容。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Fiddler",
        "question": "Fiddler与F12有什么区别?",
        "answer": "F12是浏览器内置工具, 仅针对当前网页, 强在前端调试, 操作更轻量, 适合快速定位页面问题; Fiddler是独立抓包工具, 能捕获所有设备/应用的HTTP请求, 功能更强大。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Fiddler",
        "question": "Fiddler的典型应用场景有哪些?",
        "answer": "可以用来辅助定位前后端的 bug; 可以构建模拟测试场景, 比如模拟发送请求进行接口测试, 比如 mock 接口返回数据; 还可以模拟弱网环境进行测试; 还可以对前端的性能进行分析。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Fiddler",
        "question": "Fiddler如何抓取HTTPS接口的包？",
        "answer": "1. 打开Fiddler，进入Tools → Options → HTTPS选项卡；2. 勾选Capture HTTPS CONNECTs和Decrypt HTTPS traffic；3. 安装证书生成器；点击Actions → Export Root Certificate to Desktop；4. 在PC端浏览器中导入刚才导出的Fiddler根证书。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Postman",
        "question": "Postman如何测试一个接收JSON的POST接口？",
        "answer": "1. 选择POST请求方法，输入目标URL；2. 在Headers中添加Content-Type: application/json；3. 在Body选项卡选择raw → JSON格式，填写请求体JSON数据；4. 点击Send发送请求；5. 在Response区域查看状态码、响应时间和返回的JSON数据；6. 使用Tests脚本添加断言验证响应结果（如状态码、字段值等）。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Postman",
        "question": "如何在Postman中设置环境变量？",
        "answer": "点击右上角环境管理图标 → 创建新环境 → 定义变量（如baseUrl=https://api.example.com）；在请求中使用{{variableName}}引用变量（如URL填写{{baseUrl}}/endpoint）；支持多环境切换（如测试环境、预发布环境）。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Postman",
        "question": "如何在Postman中添加断言验证响应？",
        "answer": "使用Tests脚本功能，例如：pm.test(\"Status code is 200\", () => { pm.response.to.have.status(200); }); pm.test(\"Response contains userId\", () => { const jsonData = pm.response.json(); pm.expect(jsonData.userId).to.eql(123); });"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Postman",
        "question": "Postman如何测试有接口依赖的接口？",
        "answer": "1. 通过变量管理提取接口A的响应数据并存储为环境变量，在接口B中直接引用该变量，两个放在一个测试集里设置运行顺序。2. 可以使用Pre-request Script脚本，在Pre-request Script中使用pm.sendRequest()发送依赖接口的请求，回调函数提取响应数据并存储为环境变量然后在接口中引用。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Postman",
        "question": "如何用Postman实现数据驱动测试？",
        "answer": "在Collection Runner中导入CSV/JSON文件，请求参数可以通过{{var}}来引用；断言中的数据，由于是在Tests中写入的脚本，并不能直接通过{{var}}来引用，所以需要引用Postman的相关API进行调用，如：pm.variables.get(\"var\")。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Postman",
        "question": "如何用Postman调试接口的认证流程？",
        "answer": "手动获取Token：发送认证请求，将响应中的Token保存为全局变量；后续请求在Headers中携带Authorization: Bearer {{token}}；可结合Pre-request Script自动刷新Token。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Postman",
        "question": "Postman和JMeter的区别是什么？什么时候用Postman？",
        "answer": "Postman适合轻量级API功能测试、快速验证、团队协作（共享集合）；JMeter适合高性能、并发测试、复杂场景（如分布式压测）；使用Postman的场景：单接口调试、自动化测试脚本编写、Mock Server模拟接口。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "你对JMeter有什么了解?",
        "answer": "JMeter 是一款开源的性能测试工具, 常用于对软件应用程序进行负载测试、性能测试等。JMeter 可模拟多用户并发访问、支持多种协议(如 HTTP、FTP 等)、能生成详细的测试报告。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "JMeter元件是什么？",
        "answer": "JMeter元件是JMeter性能测试的基本构建块, 如线程组、取样器、监听器等。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "如何创建一个简单的JMeter测试计划？",
        "answer": "1. 打开JMeter, 点击File → New → Test Plan；2. 输入测试计划名称, 选择线程数、循环次数等；3. 右键线程组 → 添加 → 取样器, 配置请求参数；4. 右键线程组 → 添加 → 监听器, 选择查看结果树或聚合报告。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "JMeter常用的性能测试组件有哪些？",
        "answer": "1. 线程组（Thread Group）：定义虚拟用户数量和加载模式；2. 取样器（Sampler）：发送HTTP/FTP/JDBC等请求；3. 监听器（Listener）：查看结果树、聚合报告等结果收集组件；4. 断言（Assertion）：验证响应结果；5. 定时器（Timer）：设置思考时间或固定吞吐量；6. 配置元件（Config Element）：管理测试数据（如CSV Data Set Config）；7. 前置/后置处理器（Pre/Post Processor）：处理请求前后逻辑；8. 逻辑控制器（Logic Controller）：控制测试流程（如循环、条件判断）"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "JMeter中如何添加一个HTTP请求？",
        "answer": "右键线程组 → 添加 → 取样器 → HTTP请求，填写协议、服务器名、路径、参数等。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "如何用JMeter实现参数化（登录测试）？",
        "answer": "使用CSV Data Set Config：添加配置元件 → CSV Data Set Config，指定CSV文件路径；在HTTP请求中通过${username}和${password}引用参数。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "如何在JMeter中添加断言验证响应？",
        "answer": "右键HTTP请求 → 添加 → 断言 → 响应断言，设置预期结果（如响应码200或包含特定文本）。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "如何用JMeter模拟并发用户？",
        "answer": "在线程组中设置：线程数（用户数）、Ramp-Up时间（启动间隔）、循环次数；示例：100用户，Ramp-Up 10秒 → 每秒启动10用户，持续10秒完成全部并发。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "如何用JMeter处理动态参数（如登录后的Token）？",
        "answer": "使用正则表达式提取器或JSON Extractor：右键请求 → 添加 → 后置处理器 → 正则表达式提取器，通过正则匹配响应中的Token；在后续请求中通过${token}引用。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "JMeter如何生成聚合报告？",
        "answer": "添加监听器 → 查看结果树（调试）、聚合报告（性能指标）；运行测试后，聚合报告显示TPS、平均响应时间、错误率等关键指标。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "JMeter",
        "question": "如何排查JMeter测试中出现的超时问题？",
        "answer": "检查网络延迟、服务器性能、接口响应时间；调整JMeter配置：增加超时时间（HTTP请求 → 连接/响应超时）；使用View Results Tree查看失败请求的详细日志。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "requests",
        "question": "什么时候适合用Postman？什么时候适合用requests?​",
        "answer": "Postman适合：1. 快速调试单接口；2. 可视化操作（无需编码）；3. 团队协作（共享集合）；4. 需要保存历史记录；5. 使用环境变量管理多环境配置。requests适合：1. 集成到Python自动化测试框架；2. 需要复杂逻辑处理（如数据预处理）；3. 结合pytest做参数化测试；4. 需要更高灵活性的场景；5. 持续集成(CI)流程中调用。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "requests",
        "question": "如何用Python+Requests做接口自动化？​",
        "answer": "​​封装请求​​：用requests.get/post()发送请求，添加headers/params; ​​数据驱动​​：用Excel或JSON存储测试数据（如不同登录账号）; ​​断言验证​​：检查response.status_code和response.json()里的关键字段; ​​报告生成​​：用pytest+Allure生成带请求/响应详情的报告。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "requests",
        "question": "用 requests 库发送 POST 请求, 如何传递 JSON 数据和文件？",
        "answer": "传递JSON数据：使用json参数（requests.post(url, json={'key':'value'})）。传递文件：使用files参数（requests.post(url, files={'file': open('test.txt','rb')})）。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "requests库",
        "question": "requests库的json参数传递的是Python对象还是JSON字符串？",
        "answer": "json参数接收Python对象（如dict/list），requests会自动将其序列化为JSON字符串并设置Content-Type为application/json。若手动传递JSON字符串，需使用data参数并手动设置headers={'Content-Type':'application/json'}。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "requests",
        "question": "requests遇到429 Too Many Requests错误怎么处理？​",
        "answer": "立即添加延迟：time.sleep(1); 检查API限流规则，调整测试频率; 考虑使用retrying库实现自动重试"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "requests",
        "question": "requests​如何处理SSL证书验证错误？​",
        "answer": "​​忽略证书验证​​：verify=False; 安装证书：requests.get(url, verify=‘path/to/cert.crt’)。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "requests",
        "question": "requests的session对象有什么优势？",
        "answer": "Session对象可以：保持持久连接，提升性能（特别是多次请求同一主机时）;自动处理cookies，比如登录状态维护;统一配置默认headers/auth等参数"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "requests",
        "question": "接口测试requests如何处理接口依赖（如需要先登录）？",
        "answer": "1.​​Session保持​​：用requests.Session()自动带cookie（适合简单场景）2.​​Token传递​​：先调登录接口获取token，后续请求加到headers（如Authorization: Bearer xxxx）【3.Mock数据：先mock数据，后续请求使用mock数据。】"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "unittest/pytest",
        "question": "unittest 和 pytest 的区别？你更倾向用哪个？为什么？",
        "answer": "unittest 是 Python 内置标准库, 基于类,需继承TestCase, 需用特定断言方法, 适合轻量场景比如做单元测试；pytest 是第三方框架, 语法简洁（用 assert）、夹具灵活、插件丰富（如参数化、并行测试）, 适合复杂项目。更倾向 pytest, 因其开发效率高、生态完善, 能显著提升测试体验和代码质量。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "unittest/pytest",
        "question": "pytest 中如何实现参数化？",
        "answer": "pytest 中可以通过 parametrize 装饰器实现参数化。第一个参数是字符串, 为测试函数的参数名。第二个参数是列表, 包含多组测试数据。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "unittest/pytest",
        "question": "pytest 中如何实现测试用例的依赖/如何用 fixture 管理测试前置/后置条件？？",
        "answer": "用 @pytest.fixture 装饰器定义, 通过 yield 分隔：yield 前的代码为前置操作（如创建资源）。yield 后的值会作为参数注入测试函数。测试结束后（无论成败）, 执行 yield 后的后置操作（如清理资源）。测试函数通过参数声明依赖的 fixture, 支持多 fixture 组合。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Selenium",
        "question": "介绍一下Selenium的底层原理。",
        "answer": "1) 测试脚本发送JSON格式的HTTP请求；2) 浏览器驱动（如ChromeDriver）作为服务端接收并解析这些请求；3) 驱动通过浏览器提供的自动化协议将命令转换为浏览器原生操作；4) 浏览器执行后返回响应，经驱动处理后以HTTP响应形式返回给客户端。​"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Selenium",
        "question": "介绍 Selenium 的几种等待机制。",
        "answer": "强制等待​​（time.sleep）简单但低效；​​隐式等待​​（driver.implicitly_wait）全局轮询元素；​​显式等待​​（WebDriverWait + EC）针对特定元素/条件，稳定性更好；​​流畅等待​​（自定义轮询/异常）灵活处理复杂场景"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Selenium",
        "question": "Selenium 如何处理异步加载元素/动态元素等待?",
        "answer": "使用显式等待（Explicit Wait）, 结合 WebDriverWait 和 expected_conditions。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Selenium",
        "question": "Selenium如何处理弹窗、多窗口和多标签页?",
        "answer": "使用 switch_to.alert() 或 driver.switch_to.window() 或 driver.switch_to.frame() 方法。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Selenium",
        "question": "Selenium如何处理​​下拉框（Select）？",
        "answer": "从support.ui导入Select类。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Selenium",
        "question": "Selenium如何处理​动态表格（数据行数不固定）？",
        "answer": "​​定位整个表格​​, 使用 find_elements() 方法定位所有行, 然后遍历每一行, 使用 find_elements() 方法定位所有单元格。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Selenium",
        "question": "Selenium如何处理文件上传?",
        "answer": "使用 send_keys() 方法。"
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Selenium",
        "question": "Selenium如何定位动态元素（动态元素指的是网页在加载后, 会随着用户操作、时间推移或数据更新而发生变化的元素）？",
        "answer": ""
    },
    {
        "category": "测试工具&框架",
        "subcategory": "Selenium",
        "question": "元素明明存在但Selenium找不到，都有哪些可能的原因？",
        "answer": "元素定位错误、元素未加载、元素被遮挡、元素被禁用、元素被隐藏、在iframe里等。"
    },
    {
        "category": "其他基础",
        "subcategory": "数据库",
        "question": "SQL的范式是什么?",
        "answer": "第一范式要求数据库中的每一列都是不能再分的基本数据项。第二范式要求非主属性完全依赖于主键。第三, 范式要求任何非主属性都不能依赖于其他非主属性。"
    },
    {
        "category": "其他基础",
        "subcategory": "数据库",
        "question": "数据库的事务是什么?",
        "answer": "数据库的事务是多个语句做一个整体执行, 具有原子性、一致性、隔离性和持久性。"
    },
    {
        "category": "其他基础",
        "subcategory": "数据库",
        "question": "数据库主键和外键是什么?",
        "answer": "主键是表中能够唯一标识每一行记录的一个或多个字段组合。外键是表中的一个或多个字段组合, 它的值和另一个表中的主键相匹配, 这样可以建立表之间的联系   "
    },
    {
        "category": "其他基础",
        "subcategory": "数据库",
        "question": "介绍一下数据库索引。",
        "answer": "索引是一种特殊的数据结构, 用来快速的定位和访问数据表中的数据。常见的索引有普通索引、唯一索引和组合索引。在存储结构上有哈希索引、B树索引、B+树索引。"
    },
    {
        "category": "其他基础",
        "subcategory": "数据库",
        "question": "介绍一下哈希/B树/B+树索引。",
        "answer": "哈希索引通过 HASH 函数将索引键值映射到存储位置。等值查询速度快, 但不支持范围查询。B树索引所有节点都存有键值。支持等值查询和范围查询, 但插入和删除的操作比较复杂。B+树索引非叶节点只有键, 叶子节点有值且通过有序链表连接, 适合顺序访问和范围查询。"
    },
    {
        "category": "其他基础",
        "subcategory": "数据库",
        "question": "MySQL查询语句谓词的执行顺序是什么?",
        "answer": "From Where Groupby Having Select Orderby"
    },
    {
        "category": "其他基础",
        "subcategory": "数据库",
        "question": "介绍一下联表查询，并给出不同联表查询区别。",
        "answer": "联表查询是指将多个表中的数据按照一定的条件关联起来查询。常见的联表查询有内连接、左连接、右连接、全连接。内连接只返回两个表中都存在的记录; 左连接返回左表所有记录, 右连接返回右表所有记录; 全连接返回左右表所有记录。"
    },
    {
        "category": "其他基础",
        "subcategory": "数据库",
        "question": "非关系型数据库了解多少？",
        "answer": "MongoDB是一种面向文档的非关系型数据管理系统。它没有特定的结构, 不需要先定义表, 灵活可扩展。适合存储结构不同的数据, 比如日志。Redis 是一种键值型的的内存数据库, 适合作为缓存、消息队列、分布式锁。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "介绍一下计算机网络的分层模型。",
        "answer": "OSI 七层模型从上到下是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。应用层直接为应用程序提供服务; 表示层用来处理数据的表示和转换; 会话层用来管理会话; 传输层提供主机之间端到端的通信; 网络层处理网络之间的通信, 数据链路层保障数据帧的传输和接收, 物理层负责物理介质上的信号传输"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "计算机网络网络层的协议有哪些?",
        "answer": "IP协议为每个网络设备分配唯一的 IP 地址, 负责将数据包从源地址传输到目的地址。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "计算机网络传输层的协议有哪些?",
        "answer": "TCP传输控制协议提供面向连接可靠的字节流传输; UDP用户数据报协议提供无连接的不可靠的但高效的数据传输服务。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "TCP协议的三次握手?",
        "answer": "TCP 协议的三次握手是在连接建立的时候使用的。第一次握手客户端向服务器发送一个同步报文段表示想和服务器建立连接, 包含一个客户端初始序列号。第二次握手是服务器接收到客户端的同步报文段之后会发送同步和确认报文段, 同步报文段包含服务器的初始序列号, 确认报文段是对客户端同步报文段的确认, 确认号是客户端序列号加一。第三次握手是客户端收到服务器的同步和确认报文段之后会发送一个确认报文段, 确认号是服务器序列号加一, 表示收到了服务器的同步报文段, 就此就建立了连接。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "TCP协议的四次挥手?",
        "answer": "TCP 协议的四次挥手是在连接断开的四个阶段。第一次挥手, 主动关闭方会发送一个结束报文段, 告知对方自己没有数据要发送。第二次挥手, 被动关闭方收到结束报文段会发送一个确认报文段作为应答, 这个时候被动关闭方知道主动关闭方要关闭连接, 但是被动关闭方可能还有数据要发送。第三次挥手, 等到所有数据发送完毕之后, 被动关闭方会发送一个结束报文段。第四次挥手, 主动关闭方接收到结束报文段会发送一个确认报文段作为应答, 然后等待两倍最长报文段寿命后关闭连接, 被动关闭方收到确认报文段后关闭连接。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "HTTP/HTTPS协议是什么?",
        "answer": "HTTP是超文本传输协议, 基于请求与响应模型运作, 端口号80。HTTPS是HTTP的安全版本, 它使用SSL/TLS协议进行加密通信, 端口号443。"
    },
    {
        "category": "测试基础",
        "subcategory": "接口测试",
        "question": "HTTP协议的请求结构是什么?",
        "answer": "请求一般包括请求行、请求头、请求体, 请求行里是URL、请求方法、协议版本; 请求头里一般常用有content-type; 还有认证的TOKEN之类的。请求体就是要发送的数据。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "HTTP协议的响应格式是什么?",
        "answer": "响应的格式包括状态行、响应头、空行和响应体。状态行包括协议版本、状态码、状态描述。响应头包括服务器信息、日期、内容类型、内容长度等。响应体是服务器返回的数据。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "HTTP协议常见的状态码有哪些?",
        "answer": "常见的状态吗码: 2开头是成功。3开头是重定向, 5开头是服务器错误, 4开头是客户端错误, 其中402身份未验证, 403是请求被拒绝, 404是资源未找到。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "HTTP协议的请求方法有哪些?",
        "answer": "常见的有 GET 用来获取资源, POST 用来提交数据, PUT 用来更新资源, DELETE 用来删除指定资源, HEAD 用来获取资源的头部信息, OPTIONS 做一些预检操作, 比如跨源资源共享。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "WebSocket协议了解吗?",
        "answer": "WebSocket在HTTP握手后, 在单个TCP连接上进行全双工通信, 允许服务器主动向客户端推送数据, 使得客户端、服务器可以实时双向通信。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "Socket协议了解吗?",
        "answer": "Socket是一种用于网络编程的接口, 通过它可实现不同主机上进程间的通信。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "RPC协议了解吗?",
        "answer": "RPC是一种远程过程调用协议, 允许客户端像调用本地方法一样调用远程服务。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "RESTful API了解吗?",
        "answer": "RESTful API是一种基于HTTP协议的API设计风格, 使用标准的HTTP方法(GET、POST、PUT、DELETE)来操作资源。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "介绍一下SOAP协议?",
        "answer": "SOAP 是基于 HTTP、以严格 XML 格式实现分布式系统结构化数据交互的协议，适合对稳定性和规范要求高的场景。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "介绍一下跨域问题?",
        "answer": "跨域是指浏览器从一个域的网页去请求另一个域的资源, 由于浏览器的同源策略, 会阻止这种行为。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "CORS跨源资源共享是什么?",
        "answer": "和跨源资源共享是一种浏览器的安全机制, 浏览器在向服务器发送跨源请求时, 会向服务器询问是否能接受当前源的请求。服务器会在响应头添加相关字段, 如果同意的话, 浏览器就会继续发送数据。如果不同意, 浏览器就会阻止该请求并抛出错误。"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "Cookie, Session, Token是什么? 有什么关系?",
        "answer": "Cookie 是存储在客户端(比如浏览器)中的一小段数据, session 是服务器端为每个会话用户创建的存储空间, TOKEN 是一种是服务器生成的身份验证凭证。Cookie 可以存储SessionID, 客户端通常通过Cookie传递让服务器可以通过该 ID 找到对应的 session 数据；Cookie也可以存储 TOKEN, 客户端的请求头中会携带 TOKEN, 由服务器来验证签名。Session有状态(服务器​​查询SessionID（无意义字符串）​​); Token无状态(服务器​​解密并验证签名（包含用户信息的加密字符串）)"
    },
    {
        "category": "其他基础",
        "subcategory": "计算机网络",
        "question": "介绍一下浏览器LocalStorage和Cache区别。",
        "answer": "LocalStorage 的容量比较大, 不会过期, 不会随请求一起发送。而 Cache 容量小, 可设置过期时间, 会随着请求一起发送。"
    },
    {
        "category": "其他基础",
        "subcategory": "Linux",
        "question": "Linux的常用命令有哪些?",
        "answer": "常用的由文件管理/操作、系统进程管理、网络之类的指令, 比如find搜索文件、cat查看文件、grep过滤内容、tail查看文件末尾; ps查看进程状态、kill杀死进程、top查看进程资源占用、lsof查出占用该文件(比如端口)的进程; ifconfig查看网络接口参数、netstat查看网络连接信息比如端口、curl发送请求。"
    },
    {
        "category": "其他基础",
        "subcategory": "Linux",
        "question": "Shell脚本方面有哪些了解?",
        "answer": "语法基础​​变量定义与引用($var, ${var})、条件判断(if [ -f file ])、循环(for, while)、函数定义与调用、输入输出重定向(>, >>, 2>&1)。测试中使用Shell脚本的具体场景比如自动化部署、日志分析、批量执行测试用例、结果验证、监控和报告生成等。"
    },
    {
        "category": "其他基础",
        "subcategory": "操作系统",
        "question": "同步和异步是什么?",
        "answer": "同步任务按顺序执行, 简单但低效。异步任务并发执行, 复杂但高效, 适合高并发场景。CPU 密集型用同步, I/O 密集型用异步。"
    },
    {
        "category": "其他基础",
        "subcategory": "Git",
        "question": "Git的常用命令有哪些?",
        "answer": "clone（拉取远程仓库）、add（暂存文件）、commit（提交修改）、push（推送至远程）、pull（拉取并合并更新）、branch（管理分支）、checkout（切换分支 / 恢复文件）、merge（合并分支）、status（查看状态）、diff（查看差异）、log（查看提交历史）。"
    },
    {
        "category": "其他基础",
        "subcategory": "Docker",
        "question": "Docker是什么? 和虚拟机有什么区别?",
        "answer": "Docker 是一个应用容器引擎, 可以让开发者将应用程序和环境依赖打包在一个可移植的容器之中, 之后可以在任何机器上搭建相同的环境。和虚拟机的区别主要在于层次不同, Docker共享宿主机的操作系统内核, 而虚拟机需要模拟硬件运行一个完整的操作系统, 所以 Docker 更加轻量化, 速度也更加快。"
    },
    {
        "category": "其他基础",
        "subcategory": "Docker",
        "question": "Docker的镜像和容器是什么?",
        "answer": "镜像是一个只读的模板, 包含了应用程序和环境依赖。容器是镜像的实例, 可以被启动、停止、删除。"
    },
    {
        "category": "其他基础",
        "subcategory": "Docker",
        "question": "Docker的常用命令有哪些?",
        "answer": "docker build 构建镜像; docker run 运行容器; docker ps 查看容器状态; docker stop 停止容器; docker start 启动容器; docker rm 删除容器; docker rmi 删除镜像; docker pull 拉取镜像; docker push 推送镜像; docker commit 提交容器为镜像; docker exec 进入容器。"
    },
    {
        "category": "其他基础",
        "subcategory": "Docker",
        "question": "Docker的网络有哪些?",
        "answer": "Docker 提供了三种网络模式: bridge、host、none。bridge 模式是默认模式, 容器和宿主机共享网络, 容器可以访问宿主机的网络; host 模式容器和宿主机共享网络, 容器的网络和宿主机一致; none 模式容器没有网络, 容器的网络和宿主机完全隔离。"
    },
    {
        "category": "其他基础",
        "subcategory": "Docker",
        "question": "Docker的存储有哪些?",
        "answer": "Docker 提供了三种存储模式: volume、bind、tmpfs。volume 模式是默认模式, 容器和宿主机共享存储, 容器可以访问宿主机的存储; bind 模式容器和宿主机共享存储, 容器的存储和宿主机一致; tmpfs 模式容器的存储在内存中, 容器重启后数据丢失。"
    },
    {
        "category": "其他基础",
        "subcategory": "正则表达式",
        "question": "正则表达式的常用符号有哪些?",
        "answer": "常用的有: ^ 匹配字符串的开头; $ 匹配字符串的结尾; . 匹配任意字符; * 匹配前面的字符零次或多次; + 匹配前面的字符一次或多次; ? 匹配前面的字符零次或一次; [] 匹配方括号中的任意字符; () 用于分组; | 用于匹配多个表达式中的任意一个; \\d 匹配数字; \\w 匹配字母、数字、下划线; \\s 匹配空白字符; \\b 匹配单词边界。"
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试一个登录功能？​",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": " ​​如何测试微信的“发送消息”功能？​​",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试一个搜索框的自动补全功能？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试一个分页功能？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试一个排序功能？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试一个筛选功能？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试一个购物车功能？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": " ​​如何测试文件上传接口？​",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试页面在弱网环境下的用户体验？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何验证页面资源（如图片、JS 文件）是否按预期加载？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试一个复杂的表单提交流程？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试一个包含多个页面的网站？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如何测试一个包含多个模块的系统？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "现在要求你对抖音点赞功能设计测试方案，请：划分等价类（考虑网络/用户状态/视频属性）设计自动化测试框架（选型+关键难点）",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "如果一个接口测试失败了，你会如何进行调试？​",
        "answer": "回答要点：可以描述从检查请求参数、查看接口返回信息、查看日志、分析错误原因到解决问题的步骤。"
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "​​支付接口测试要注意什么？​",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "​​​如何处理验证码？​",
        "answer": "分场景：​​测试环境​​让开发提供万能验证码（如‘666666’）/禁用验证码功能; ​​生产环境​​使用第三方OCR服务/先手动登录获取cookie绕过验证。"
    },
    {
        "category": "开放性问题",
        "subcategory": "实战",
        "question": "页面元素频繁变化，如何让脚本更健壮？​​",
        "answer": "优先用稳定的id; 避免绝对XPath，用利用稳定的邻近元素相对定位;​​容错设计try-except​​+重新查找; 不要依赖单一参考元素而是组合多个条件,使用or多重验证; 用​隐式等待​等。"
    },
    {
        "category": "开放性问题",
        "subcategory": "项目",
        "question": "在过去的项目中, 你用 Python 解决了哪些复杂的测试问题？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "项目",
        "question": "你在项目中遇到了什么问题/难点？是怎么解决的？",
        "answer": "可能因为一些网络加载原因，测试每次结果都不一致/误报 -> ​使用​显式等待​解决/超时​重试机制​解决..."
    },
    {
        "category": "开放性问题",
        "subcategory": "项目",
        "question": "手工测试发现的最复杂缺陷是什么？如何复现和定位的？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "项目",
        "question": "描述一个你设计的自动化测试框架, 核心模块是什么？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "工作",
        "question": "如果让你测试自己开发过的App，你会重点关注哪些方面？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "工作",
        "question": "给你一个全新功能，怎么开始测试？​",
        "answer": "先看需求文档，明确功能范围和验收标准; 找产品经理确认模糊点（比如‘用户超时’具体是几分钟？）; 把大功能拆成小点（如注册功能拆为短信验证、密码规则等）; 优先级​​：先测核心流程（如注册→登录），再测边缘情况。"
    },
    {
        "category": "开放性问题",
        "subcategory": "工作",
        "question": "​​​如果需求文档不完整，你怎么测试？​​",
        "answer": "我会​​主动沟通​​：拉会议和产品/开发对齐缺失细节; ​​参考竞品​​：看看类似功能怎么设计的; ​​记录风险​​：在测试报告里注明‘因需求不明确，XX功能未覆盖’。"
    },
    {
        "category": "开放性问题",
        "subcategory": "工作",
        "question": "如果你提交了缺陷, 开发说这不是BUG怎么办?",
        "answer": "我会提供完整复现步骤和证据​​（如截图、日志）；​​对照需求文档​​确认是否确实不符合，如果是需求理解差异，补充测试用例；​​必要时​​沟通协商, 请项目经理或测试组长评估。"
    },
    {
        "category": "开放性问题",
        "subcategory": "工作",
        "question": "​​测试环境发现Bug但生产环境没有，如何排查？​",
        "answer": "我会对比环境配置、代码版本，尝试在测试环境稳定复现，并检查部署流程是否规范。"
    },
    {
        "category": "开放性问题",
        "subcategory": "工作",
        "question": "发现一个偶现性bug但无法稳定复现，你会如何推进？需要哪些团队协作？",
        "answer": "​​​记录操作步骤、环境、时间等上下文​尽量复现；​让开发配合检查报错时的系统日志；在测试环境部署日志工具，等Bug再次出现时抓取现场数据。"
    },
    {
        "category": "开放性问题",
        "subcategory": "个人",
        "question": "你觉得你有什么优缺点?",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "个人",
        "question": "你认为前端技术对测试工程师的重要性是什么？",
        "answer": "了解前端技术，有助于更深入理解软件的用户界面部分，从而更精准地发现界面相关的问题。同时，能够更好地与前端开发人员沟通协作，提高问题定位和解决的效率，保证软件产品的用户体验和质量。 "
    },
    {
        "category": "开放性问题",
        "subcategory": "个人",
        "question": "你的职业规划是什么?未来想深入前端开发还是继续专注测试？",
        "answer": ""
    },
    {
        "category": "开放性问题",
        "subcategory": "个人",
        "question": "你为什么选择测试岗位而非开发？​",
        "answer": "测试需要逻辑思维和细致观察，我享受发现隐藏问题并推动解决的过程。开发经验让我能更快定位缺陷根源，例如通过代码逻辑反推测试用例。希望从测试切入，未来向测试开发（SDET）或自动化测试方向发展。"
    },
    {
        "category": "开放性问题",
        "subcategory": "个人",
        "question": "你有什么想问我的吗?",
        "answer": ""
    }
]